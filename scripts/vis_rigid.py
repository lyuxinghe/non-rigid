import os
import numpy as np
import open3d as o3d

def visualize_point_cloud_with_ply(file_path, save_dir, views="all"):
    """
    Visualize a point cloud from a .ply file generated by viz_predicted_vs_gt_local
    and save the rendered views.

    Args:
        file_path (str): Path to the .ply file.
        save_dir (str): Directory to save the rendered views.
        views (str): The view to render ("all", "default", "top", "side", "diagonal").

    Raises:
        ValueError: If the file extension is unsupported.
    """
    # Define supported views
    supported_views = ["default", "top", "side", "diagonal"]

    # Validate input view(s)
    if views != "all" and views not in supported_views:
        raise ValueError(f"Invalid view: {views}. Supported views are {supported_views + ['all']}.")

    # Create the subdirectory based on the input file name
    file_name = os.path.splitext(os.path.basename(file_path))[0]
    save_dir = os.path.join(save_dir, file_name)
    os.makedirs(save_dir, exist_ok=True)

    # Load the .ply file
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")

    point_cloud = o3d.io.read_point_cloud(file_path)

    # Compute bounding box for dynamic camera positioning
    bounding_box = point_cloud.get_axis_aligned_bounding_box()
    center = bounding_box.get_center()
    extent = bounding_box.get_extent()

    # Define camera positions for views
    camera_views = {
        "default": center + np.array([0, 0, max(extent) * 2.5]),
        "top": center + np.array([0, max(extent) * 2.5, 0]),
        "side": center + np.array([max(extent) * 2.5, 0, 0]),
        "diagonal": center + np.array([max(extent) * 2.5, max(extent) * 2.5, max(extent) * 2.5]),
    }

    # Determine which views to render
    views_to_render = supported_views if views == "all" else [views]

    # Render and save each view
    width, height = 1920, 1080  # Resolution
    for view in views_to_render:
        eye = camera_views[view]
        up = [0, 1, 0]

        # Create OffscreenRenderer
        scene = o3d.visualization.rendering.OffscreenRenderer(width, height)
        scene.scene.add_geometry("point_cloud", point_cloud, o3d.visualization.rendering.MaterialRecord())
        scene.scene.camera.look_at(center.tolist(), eye.tolist(), up)

        # Render the image and save it
        image = scene.render_to_image()
        save_path = os.path.join(save_dir, f"{view}_view.png")
        o3d.io.write_image(save_path, image)
        print(f"Saved {view} view visualization to {save_path}")

        # Explicitly clear the renderer to free up resources
        scene.scene.clear_geometry()
        del scene  # Ensure the renderer is destroyed


def visualize_point_cloud(file_path, save_dir, views="all"):
    # Define supported views
    supported_views = ["default", "top", "side", "diagonal"]

    # Validate input view(s)
    if views != "all" and views not in supported_views:
        raise ValueError(f"Invalid view: {views}. Supported views are {supported_views + ['all']}.")

    # Create the subdirectory based on the input file name
    file_name = os.path.splitext(os.path.basename(file_path))[0]
    save_dir = os.path.join(save_dir, file_name)
    os.makedirs(save_dir, exist_ok=True)

    # Load the NPZ file
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"File not found: {file_path}")

    data = np.load(file_path)
    if "clouds" not in data or "classes" not in data:
        raise ValueError("Invalid file format. Keys 'clouds' and 'classes' are required.")

    # Extract point clouds and classes
    points_raw = data["clouds"]
    classes_raw = data["classes"]

    # Separate action and anchor point clouds
    action_pc = points_raw[classes_raw == 0]
    anchor_pc = points_raw[classes_raw == 1]

    # Create Open3D point clouds
    action_cloud = o3d.geometry.PointCloud()
    anchor_cloud = o3d.geometry.PointCloud()
    action_cloud.points = o3d.utility.Vector3dVector(action_pc)
    anchor_cloud.points = o3d.utility.Vector3dVector(anchor_pc)
    action_cloud.paint_uniform_color([1, 0, 0])  # Red
    anchor_cloud.paint_uniform_color([0, 0, 1])  # Blue

    # Compute bounding box for dynamic camera positioning
    combined_cloud = action_cloud + anchor_cloud
    bounding_box = combined_cloud.get_axis_aligned_bounding_box()
    center = bounding_box.get_center()
    extent = bounding_box.get_extent()

    # Define camera positions for views
    camera_views = {
        "default": center + np.array([0, 0, max(extent) * 2.5]),
        "top": center + np.array([0, max(extent) * 2.5, 0]),
        "side": center + np.array([max(extent) * 2.5, 0, 0]),
        "diagonal": center + np.array([max(extent) * 2.5, max(extent) * 2.5, max(extent) * 2.5]),
    }

    # Determine which views to render
    views_to_render = supported_views if views == "all" else [views]

    # Render and save each view
    width, height = 1920, 1080  # Resolution
    for view in views_to_render:
        eye = camera_views[view]
        up = [0, 1, 0]

        # Create OffscreenRenderer
        scene = o3d.visualization.rendering.OffscreenRenderer(width, height)
        scene.scene.add_geometry("action", action_cloud, o3d.visualization.rendering.MaterialRecord())
        scene.scene.add_geometry("anchor", anchor_cloud, o3d.visualization.rendering.MaterialRecord())
        scene.scene.camera.look_at(center.tolist(), eye.tolist(), up)

        # Render the image and save it
        image = scene.render_to_image()
        save_path = os.path.join(save_dir, f"{view}_view.png")
        o3d.io.write_image(save_path, image)
        print(f"Saved {view} view visualization to {save_path}")

        # Explicitly clear the renderer to free up resources
        scene.scene.clear_geometry()
        del scene  # Ensure the renderer is destroyed


def are_anchor_pcds_identical(file_paths):
    """
    Check if the anchor point clouds from a list of .npz files are identical.

    Args:
        file_paths (list): List of file paths to .npz files.

    Returns:
        bool: True if all anchor point clouds are identical, False otherwise.
    """
    if not file_paths:
        raise ValueError("File paths list is empty.")

    # Load the anchor point cloud from the first file
    first_file_path = file_paths[0]
    if not os.path.exists(first_file_path):
        raise FileNotFoundError(f"File not found: {first_file_path}")
    
    first_data = np.load(first_file_path)
    if "clouds" not in first_data or "classes" not in first_data:
        raise ValueError(f"Invalid file format in {first_file_path}. Keys 'clouds' and 'classes' are required.")
    
    # Extract the anchor point cloud from the first file
    first_anchor_pc = first_data["clouds"][first_data["classes"] == 1]
    print(first_anchor_pc.shape)

    # Check against the rest of the files
    for file_path in file_paths[1:]:
        if not os.path.exists(file_path):
            raise FileNotFoundError(f"File not found: {file_path}")
        
        data = np.load(file_path)
        if "clouds" not in data or "classes" not in data:
            raise ValueError(f"Invalid file format in {file_path}. Keys 'clouds' and 'classes' are required.")
        
        # Extract the anchor point cloud
        anchor_pc = data["clouds"][data["classes"] == 1]
        print(anchor_pc.shape)

        # Check if the anchor point clouds are identical
        if not np.array_equal(first_anchor_pc, anchor_pc):
            print(f"Anchor point clouds differ in file: {file_path}")
            return False

    print("All anchor point clouds are identical.")
    return True


if __name__ == "__main__":
    '''
    file_path = "/data/lyuxing/tax3d/ndf/mugplace/train_data/renders/0_init_obj_points.npz"  # Replace with actual file path
    save_dir = "./vis"  # Directory to save the visualizations
    views = "all"  # Use "all" or any single view like "default", "top", "side", "diagonal"
    visualize_point_cloud(file_path, save_dir, views)
    '''
    '''
    file_list = [
        "/data/lyuxing/tax3d/ndf/mugplace/train_data/renders/0_init_obj_points.npz",
        "/data/lyuxing/tax3d/ndf/mugplace/train_data/renders/0_afterteleport_obj_points.npz",
        "/data/lyuxing/tax3d/ndf/mugplace/train_data/renders/0_teleport_obj_points.npz",
    ]  # Replace with the actual file paths
    are_anchor_pcds_identical(file_list)
    '''

    file_path = "/home/lyuxing/Desktop/tax3d_upgrade/scripts/logs/train_ndf_df_cross/2025-01-26/15-24-03/vis/step_0_viz.ply"
    save_dir = "./vis"
    views = "all" 
    visualize_point_cloud_with_ply(file_path, save_dir, views)
